#### 새로 들어가는 회사에서 MSA로 이미 서버가 돌아가고 있다고 해서... 급하게 책을 읽고 정리한 것을 적은 곳!

#### 마이크로 서비스 아키텍처
* 마이크로 서비스 아키텍처 : 아주 작은 단위로 동작하는 서비스가 구동되로록 시스템 및 소프트웨어의 구성과 구성 요소 간의 관계를 정의한 
아키텍처

#### 서비스지향 아키텍처의 특징
1. 서비스 계약 : 약속한 기능을 수행, 서비스 소비자는 서비스를 사용하기 위한 계약 규칙을 준수해야함.
2. 서비스 가용성 : 서비스들의 가용성을 보장하기 위해 타임아웃 기능 구현을 제안함. (A서비스로 요청에도 불구하고 답이 없으면 다른 서비스로 요청경로를 수정)
3. 보안 : 서비스끼리 호출할 때 인증, 및 보안을 적용해야 함.
4. 트랜잭션 : 서비스에서 발생하는 트랜잭션들에 대한 일관성 유지 (읽기 전용 DB와, 쓰기 및 데이터 조작 DB를 분리 구성)
5. 서비스 관리 : 서비스가 동적으로 증가하거나 하고, 특정 서비스에 장애가 발생하면 정상적인 서비스로 이동하도록 요청 흐름등을 변경 가능해야 함.

#### 마이크로 서비스의 이해
* 작은 서비스 : 쇼핑몰 앱이라면 구매 서비스, 물건 관리 서비스, 배송 서비스 이런식으로 나뉘어야 되나봐요!
* 독립된 서비스 : 독립적으로 실행 가능, 다른 서비스들과 결합이 없음. 구현 배포 뿐만이 아닌 장애측면에서도 독립적
* 응집된 서비스 : 한가지의 서비스를 위한 기능들로 구현되어야 함.
* 자율적 서비스 : 개발, 배포, 테스트 증 독립적으로 의사결정을 하고, 서비스에 대한 책임을 짐.(서비스를 개발하는 개발팀의 자율성)

##### 마이크로 서비스 서비스 분할
* 하향식 : 업무의 흐름을 기준으로 핵심적인 것과 비핵심적인 것을 나눈다
* 상향식 : 데이터의 특성을 고려해서 분할한다
* 점진적 분할 : 통으로 되어있는 것을 영향이 적은 것부터 하나씩 바꿔나간다


### DDD Start를 읽고...
 ~~MSA 책읅 읽었더니 DDD얘기가 넘모 많이 나와 읽어보았다... 원래는 다 읽고 하려고 했는데... 넘모 늘어져서 중간정리를... 객체지향의 사실과 오해랑 비슷한 느낌...~~
 * 도메인 
    * 도메인은 여러 하위 도메인으로 구성된다
    * 도메인 모델은 특정 도메인을 `개념적`으로 표현한 것 (주문, 장바구니, 주소 등등)
    * 도메인 모델패턴엔 4가지 계층이 있다
      * 표현 :  사용자의 요청을 처리하고 사용자에게 정보를 보여줌 (@Controller가 붙은 애들..?)
        * HTTP 요청을 응용이가 사용할 수 있는 형식으로 변환해서 전달, 응용이의 리턴을 HTTP 형식으로 변환해서 전송
      * 응용 : 사용자가 요청한 기능을 수행 서비스자체에서 실행하기 보단 해당 도메인의 기능을 수행하게 함  (@Service가 붙은 애들..?)
      ``` 
      UserService {
        changeUserName(User user) {
            user.changeName();
        }
      }
      ```
      * 도메인 : 서비스에서 제공할 도메인을 구현
      * 인프라스트럭쳐 : DB처럼 외부 시스템과의 연동을 처리 
        * RDBMS를 연동하거나... DB연동을 처리하거나... 실제구현을 다룸
    * 계층구조에선 표현이 응용을 의존하지만, 응용이 표현을 의존하게 하진 않는다고 함
    * 도메인은 엔티티와 밸류로 구성된다
      * 엔티티 : 식별자를 가지는 녀석(식별자가 같으면 같은 녀석), 객체만의 라이프사이클을 가짐, 해당데이터와 관련된 기능을 함께 제공
      * 밸류 : 개념적으로 완전한 하나를 표현할 떄 사용 -> 이러면 읽을 때 얘가 뭐에 관련된 녀석인지 파악이 더 용이해짐!
          ``` 
          public class Money {
            private String currency;
            private String amount;
          } 
          ```
         * 이 녀석에게 행동을 부여하기가 더 쉬워짐(객체지향에서 객체는 능동적이니까) ex) Money.minus() 이런느낌...?
         * 되도록 불변객체로 생성하세욤...! -> 참조 투명성과 스레드에 안전
     * DIP : 저수준 모듈이 고수준 모듈에 의존하도록 함 -> 인터페이스를 쓰자!
     * 애그리거트 : 관련 객체를 하나로 묶은 군집, 애그리거트 간의 관계로 도메인 모델을 이해 구현할 수 이게 된다고 함 ㅇㅁㅇ;;;
       * 한 애그리거트에 속한 객체는 유사하거나 동일한 라이프사이클을 가짐
       * 애그리거트 루트 : 애그리거트에 속한 녀석들을 일관된 상태로 유지하기 위한 관리 주체.. 일관성이 깨지지 않도록 해야 함 ~~리더 애그리거트 느낌..~~
         * 필드 변경하는 public setXxx()메서드 등을 만들지 않는다 -> 생성자로 하거나, 행위를 부여해야 함 (ex. root.changeMyMoney())
    * 리파지토리 : 물리적인 장소에 도메인 녀석을 저장하기 위한 모델 (JPA에서 쓰는 @Repository로 보면 될 듯)
      * 애그리거트 루트는 엔티티니까 @Entity로 매핑 설정 (요기는 나중에 JPA로 따로 정리하는게 맞으시거따아..)
      * 한 테이블에 엔티티, 밸류가 같이 있으면
        * 밸류는 @Embeddable
        * 밸류 타입 프로퍼티는 @Embedded로 매핑 설정
      * @Converter어노테이션을 쓰면 Money타입등을 바꿔서 저장가능  
      * 저장할 때도, 삭제할 때도 애그리거트 루트와 애그리거트에 있는 관련 된 애들도 싹 처리해 줘야함
        * @Embeddable 매핑이면 저장, 삭제가 같이 되지만 @Entity 타입 매핑은 @Cascade로 해야 된대 (@OneToOne, @OneToMany)
          ```
            @OneToMany(cascade = {CascadeType.PERSIST, CascateType.REMOVE} ....)
          ```
       * 조회 통계등은 JPQL이나 Creteria로 처리하기 힘드니 직접 쿼리를 작성하자 (망함...)
       * @Subselect는 쿼리결과를 @Entity로 매핑가능한 어노테이션
* 응용서비스 영역
  * 요청을 처리하기 위해 리파지토리로부터 도메인 객체를 구하고, 도메인 객체를 사용함
  * 도메인 로직은 도메인에게 맡기자!
  * 트랜잭션 처리를 하자 @Transactional 어노테이션을 붙입시다
  * 도메인 이벤트 처리 (Events.raise(....))
  * 데이터의 존재 유무 등... 
* 표현 영역
  * 사용자가 접근 가능한 화면의 흐름을 제공하고 제어함
  * 요청을 알맞은 응용서비스에 위임한다
  * 사용자의 세션을 관리한다
    * 값 검증 (@Validation)
* 애그리거트 트랜잭션 관리
  * 선점과 비선점이 있음 (여기는 그림이 있어야 편한데 나중에 그림 구하면 넣음)
    * 선점 : A스레드가 해당 애그리거트를 수정중이면 어떤 스레드던 수정 못하게 락 걸어놓음
      * 데드락이 발생할 수 있다 -> javax.persistence.lock.timeout 힌트를 주면 시간 경과시 익셉션이 나고 데드락 회피 가능하다네염
      ```
      entityManager.find(A.class, ANo, LockModeType.PESSIMISTIC_WRITE); 로 하면 선점한다고 하네염 
      ```
     * 오프라인 선점 : 여러 트랜잭션에 걸쳐 동시 변경을 막음 첫 번째 트랜잭션을 시작할 때 오프라인 잠금을 선점하고, 마지막 트랜잭션에서 잠금을 해제함. 잠금을 해제하기 전까지 다른 사용자는 잠금을 구할 수 없다고 함
       * 유효시간이 지나면 자동으로 잠금을 해제해서 다른 사용자가 접근 가능하도록 해야함
    * 비선점 : 변경한 데이터를 실제 DBMS에 반영하는 시점에 변경 가능 여부를 확인하는 방식
      * 애그리거트에 버전으로 쓸 프로퍼티를 추가하고, 애그리거트 수정이 될 때마타 버전을 +1 하고, 수정할 때 내 애그리거트 버전과 현재 애그리거트 버전이 같으면 가능
      (애증의 이선좌가 비선점인건가욤)
      * 버전으로 쓸 프로퍼티에 @Version 어노테이션을 붙이면 됨
  